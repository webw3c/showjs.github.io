<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乘风之歌</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://webw3c.github.io/atom.xml" rel="self"/>
  
  <link href="https://webw3c.github.io/"/>
  <updated>2019-09-03T10:20:08.716Z</updated>
  <id>https://webw3c.github.io/</id>
  
  <author>
    <name>PAN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Hooks 入门</title>
    <link href="https://webw3c.github.io/2019/09/03/reacthooks/"/>
    <id>https://webw3c.github.io/2019/09/03/reacthooks/</id>
    <published>2019-09-03T07:53:13.000Z</published>
    <updated>2019-09-03T10:20:08.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://reactjs.org/docs/hooks-reference.html">React Hooks</a> 是 React v16.8 版本中引入的新特性，阅读本文需要一定的 React 基础。</p><h2 id="一、Hooks-出现的原因"><a href="#一、Hooks-出现的原因" class="headerlink" title="一、Hooks 出现的原因"></a>一、Hooks 出现的原因</h2><p>React 的核心是组件。v16.8 版本之前，组件的标准写法是类，还有一种就是函数式组件或者(说是无状态组件)。</p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>下面是一个简单的类组件示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;点击了 &#123; <span class="built_in">this</span>.state.count &#125; 次&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123; <span class="built_in">this</span>.addCount.bind(<span class="built_in">this</span>) &#125;&gt;确定&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addCount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Demo;</span><br></pre></td></tr></table></figure><p>组件类的几个缺点：</p><ul><li>大型组件很难拆分和重构，也很难测试。</li><li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li></ul><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>要求必须是一个纯函数，不能包含状态，不支持生命周期方法。</p><h3 id="React-Hooks-设计目的"><a href="#React-Hooks-设计目的" class="headerlink" title="React Hooks 设计目的"></a>React Hooks 设计目的</h3><p>所以 React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。 </p><h2 id="二、Hook-的含义"><a href="#二、Hook-的含义" class="headerlink" title="二、Hook 的含义"></a>二、Hook 的含义</h2><p>Hook 这个单词的意思是”钩子”。<br>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。</p><p>所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p><p>下面介绍 React 默认提供的四个最常用的钩子。</p><ul><li>useState()</li><li>useContext()</li><li>useReducer()</li><li>useEffect()</li></ul><h2 id="三、useState-：状态钩子"><a href="#三、useState-：状态钩子" class="headerlink" title="三、useState()：状态钩子"></a>三、useState()：状态钩子</h2><p>useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p><p>本文前面那个组件类，用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用useState()重写如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, addCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;点击了 &#123; count &#125; 次&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123; addCount(count+<span class="number">1</span>) &#125;&#125;&gt;确定&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Demo;</span><br></pre></td></tr></table></figure><p>useState() 函数接受状态的初始值，作为参数，上例的初始值为要展示的数值0。该函数返回一个长度为2的数组，数组的第一个值是一个变量（上例是count），指向状态的当前值。第二个值是一个函数，用来更新状态。</p><p>** useState 使用注意 **<br>useState 的执行顺序在每一次更新渲染时必须保持一致，否则多个 useState 调用将不会得到各自独立的状态，也会造成状态对应混乱。比如在条件判断中使用 hook，在循环，嵌套函数中使用 hook，都会造成 hook 执行顺序不一致的问题。最后导致状态的混乱。另外，所有的状态声明都应该放在函数顶部，首先声明。</p><h2 id="四、useContext-：共享状态钩子"><a href="#四、useContext-：共享状态钩子" class="headerlink" title="四、useContext()：共享状态钩子"></a>四、useContext()：共享状态钩子</h2><p>如果需要在组件之间共享状态，可以使用useContext()。</p><p>现在有两个组件 Navbar 和 Messages，我们希望它们之间共享状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个共享状态</span></span><br><span class="line"><span class="keyword">const</span> UserContext = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Navbar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// useContext() 钩子函数用来引入 Context 对象，从中获取username属性。</span></span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(UserContext)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;A 组件里的用户：&#123; username &#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Messages = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// useContext() 钩子函数用来引入 Context 对象，从中获取username属性。</span></span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(UserContext)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;B 组件里的用户：&#123; username &#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// UserContext.Provider提供了一个 Context 状态共享对象，这个对象可以被子组件共享。</span></span><br><span class="line">    &lt;UserContext.Provider value=&#123;&#123; <span class="attr">username</span>: <span class="string">&#x27;PAN~~~&#x27;</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Navbar /&gt;</span><br><span class="line">        &lt;Messages /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/UserContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="五、useReducer-：action-钩子"><a href="#五、useReducer-：action-钩子" class="headerlink" title="五、useReducer()：action 钩子"></a>五、useReducer()：action 钩子</h2><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p><p>Redux 的核心概念是，组件发出 action 与状态管理器通信(store)。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，然后再返回给状态 管理通信器，Reducer 函数的形式是(state, action) =&gt; newState。</p><p>useReducers()钩子用来引入 Reducer 功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure><p>useReducer() 接收 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的 dispatch 函数。</p><p>下面看一个简单的计数器效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于计算状态的 Reducer 函数</span></span><br><span class="line"><span class="keyword">const</span> myReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;countUp&#x27;</span>):</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(myReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;countUp&#x27;</span> &#125;)&#125;&gt;</span><br><span class="line">        +<span class="number">1</span></span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="六、useEffect-：副作用钩子"><a href="#六、useEffect-：副作用钩子" class="headerlink" title="六、useEffect()：副作用钩子"></a>六、useEffect()：副作用钩子</h2><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。具体用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()  =&gt;</span>  &#123;</span><br><span class="line">  <span class="comment">// Async Action</span></span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure><p>上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。</p><p>** 注意 **<br>第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</p><p>下面看一下实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">&#123; personId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://easy-mock.com/mock/5d53bf7452cb451e4e23fd53/study/getPerson?id=<span class="subst">$&#123;personId&#125;</span>`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;First Loading...&#x27;</span>)</span><br><span class="line">        setPerson(data.data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);</span><br><span class="line">  <span class="comment">// 每当组件参数personId发生变化，useEffect()就会执行。</span></span><br><span class="line">  <span class="comment">// 组件第一次渲染时，useEffect()也会执行。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名: &#123;person.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;年龄: &#123;person.age&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = useState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;Person personId=&#123;show&#125; /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setShow(<span class="string">&quot;1&quot;</span>)&#125;&gt;Person <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setShow(<span class="string">&quot;2&quot;</span>)&#125;&gt;Person <span class="number">2</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="七、创建自己的-Hooks"><a href="#七、创建自己的-Hooks" class="headerlink" title="七、创建自己的 Hooks"></a>七、创建自己的 Hooks</h2><p>下面的示例以上面的例子为基础，自定义一个 Hooks，usePerson()就是一个自定义的 Hook。</p><p>Person 组件就改用这个新的钩子，引入封装的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usePerson = <span class="function"><span class="params">personId</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://easy-mock.com/mock/5d53bf7452cb451e4e23fd53/study/getPerson?id=<span class="subst">$&#123;personId&#125;</span>`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        setPerson(data.data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);</span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="keyword">return</span> [loading, person];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">&#123; personId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, person] = usePerson(personId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名: &#123;person.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;年龄: &#123;person.age&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = useState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;Person personId=&#123;show&#125; /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setShow(<span class="string">&quot;1&quot;</span>)&#125;&gt;Person <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setShow(<span class="string">&quot;2&quot;</span>)&#125;&gt;Person <span class="number">2</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/hooks-reference.html&quot;&gt;React Hooks&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS原型和原型链</title>
    <link href="https://webw3c.github.io/2019/03/20/jsprototype/"/>
    <id>https://webw3c.github.io/2019/03/20/jsprototype/</id>
    <published>2019-03-20T04:30:08.000Z</published>
    <updated>2021-03-25T02:00:26.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的-prototype-属性"><a href="#函数的-prototype-属性" class="headerlink" title="函数的 prototype 属性"></a>函数的 prototype 属性</h2><ul><li>每个<strong>函数对象</strong>都有一个 prototype 属性，它默认指向一个Object空对象（即称原型对象）</li><li>原型对象：函数有一个属性 prototype，这个属性的值是一个对象，所以我们称这个对象为原型(prototype)对象</li><li>函数对象：为什么说是函数对象呢？因为在函数上面才有 prototype 属性，我们使用时是使用<code>函数名.prototype</code>，可以看出函数是看作对象看，如果对象不是函数对象，是没有 prototype 属性的，比如 new Object，所以说只有函数对象才 prototype 属性，所有的函数都有显式原型属性</li></ul><p>函数对象 prototype 属性是引用类型属性，指向原型对象，关系看下图：</p><p><img src="https://i.loli.net/2020/11/13/AjkfbRqHzMdx9Vm.png" alt="https://i.loli.net/2020/11/13/AjkfbRqHzMdx9Vm.png"></p><p>prototype 是什么时候被添加到函数上去的？函数创建的时候，那什么时候创建函数对象呢？函数定义的时候，执行函数定义的时候，this.prototype = {}</p><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test.prototype)</span><br><span class="line"><span class="comment">// &#123;constructor: f test()&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以给原型对象添加属性和方法，好比如 Date 类型其实内置了很多方法，其实就是通过 Date.prototype 添加上去的</span></span><br><span class="line">test.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test.prototype)   <span class="comment">// 原型对象增加了say()方法</span></span><br></pre></td></tr></table></figure><p>prototype是函数的属性，这个属性(prototype)指向一个Object空对象，但这个空对象的意思就是没有我们自己定义的属性，其实是有一个constructor属性的</p><p>给原型对象添加属性（一般是方法），是为了给实例对象访问</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Test.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Test()</span><br><span class="line"><span class="built_in">console</span>.log(t.say())    <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>原型对象中有一个属性 constructor，指向函数对象</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.constructor === <span class="built_in">Date</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test.prototype.constructor === test)</span><br></pre></td></tr></table></figure><h2 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h2><ul><li>每个函数function都有一个 prototype 属性，即显式原型（属性）</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype)</span><br></pre></td></tr></table></figure><ul><li>每个<strong>实例对象</strong>都有一个 <strong>proto</strong> 属性，即隐式原型（属性）</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype)</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__)</span><br></pre></td></tr></table></figure><ul><li><strong><em>实例对象的隐式原型(属性)的值，是其对应构造函数的显式原型(属性)值</em></strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__ === Fn.prototype)</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;    <span class="comment">// 内部语句：this.prototype = &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype, fn.__proto__)</span><br><span class="line">***<span class="built_in">console</span>.log(Fn.prototype === fn.__proto__)***</span><br><span class="line"></span><br><span class="line">Fn.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">// 内部语句：this.__proto__ = Fn.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.sayHi()  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/12/aAuPo4K79mrc6p3.png" alt="https://i.loli.net/2020/11/12/aAuPo4K79mrc6p3.png"></p><blockquote><p>显式原型与隐式原型总结：<br>函数的 <code>prototype</code> 属性：在函数定义时自动添加的，默认值是一个空Object对象；<br>对象的<code>__proto__</code> 属性：在创建对象时自动添加的，默认值是构造函数的原型(prototype)属性值；<br>程序可以直接操作显式原型，但不能直接操作隐藏原型（ES6之前）</p></blockquote><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>访问一个对象的属性时：</p><ul><li>先在自身属性查找，找到就返回</li><li>如果没有，再沿着__proto__这条链向上查找，找到返回</li><li>如果最终没找到，返回undefined</li></ul><p>原型链接别名也叫隐式原型链接，因为它是沿着__proto__向上查找的</p><p>作用：查找对象属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.test1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;test1()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;test2()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span>  fn = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line"><span class="built_in">console</span>.log(fn.toString())</span><br><span class="line">fn.test3()</span><br></pre></td></tr></table></figure><p>这里有个关键就是Object空对象的__proto__属性值是怎么来的，其实就是JS运行时加载了内置的Object，就是里面的原型(prototype)属性的值</p><p><img src="https://i.loli.net/2020/11/12/GBynumZ68Jiew3E.png" alt="https://i.loli.net/2020/11/12/GBynumZ68Jiew3E.png"></p><p>Object.prototype.<strong>proto</strong>  // null</p><h2 id="实例、构造函数、原型对象关系"><a href="#实例、构造函数、原型对象关系" class="headerlink" title="实例、构造函数、原型对象关系"></a><strong>实例、构造函数、原型对象关系</strong></h2><p>1、函数的显式原型(prototype)指向的对象，默认是空 Object <strong>实例</strong>对象（但Object不满足）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>)       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2、所有函数都是 Function 的实例，包含 Function 自己</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br></pre></td></tr></table></figure><p>3、Object 的原型对象是是原型链尽头</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/12/Sa4Bzjf5NvE9dP6.png" alt="https://i.loli.net/2020/11/12/Sa4Bzjf5NvE9dP6.png"></p><p>关系图</p><h2 id="原型链属性问题"><a href="#原型链属性问题" class="headerlink" title="原型链属性问题"></a>原型链属性问题</h2><ol><li>读取对象的属性时：会自动到原型链中查找</li><li>设置对象的属性时；不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置它的值</li><li>方法一般定义在原型上，属性一般通过构造函数定义在对象本身上</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype.a = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(fn1.a)  <span class="comment">// fn1本身是没有a属性的，没有它会沿在__proto__查找，在构造函数的 prototype 上找到了并返回</span></span><br><span class="line"><span class="built_in">console</span>.log(fn1)    <span class="comment">// 实例对象的 fn1.__proto__ === Fn.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> Fn()</span><br><span class="line">fn2.a = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(fn1.a, fn2.a, fn2)</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 是如何判断的？</p><p>表达式：A instanceof B，A是实例对象，B是构造函数，就是说 A 是不是 B 的实例</p><p>首先要清楚 A 是实例对象看的是隐式原型<strong>proto__，B是构造函数看的是 prototype，如果 B 的 prototype 在 A 的 __proto</strong> 上，返回 true，换句话说：右边的 prototype 在 左边的 <strong>proto</strong> 上返回 true</p><p>所有我们定义的函数的原型对象，都是 Object 的实例</p><p>几道思考题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题一</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考上面的关系图。function Object → Object created by Function → function Function<br>也就是说 Object 是构造函数 Function 的实例对象，实例对象有隐式原型属性 Object.<strong>proto</strong> === Function.prototype</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题二</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这一题 A 和 B 都是 Object，但</p></blockquote><p><img src="https://i.loli.net/2020/11/13/r3QMTogeD1tuzFy.png" alt="https://i.loli.net/2020/11/13/r3QMTogeD1tuzFy.png"></p><p>题二示意图</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题三</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)</span><br></pre></td></tr></table></figure><blockquote><p>要注意，Function 是 new 自己产生的</p></blockquote><p><img src="https://i.loli.net/2020/11/13/KnazqhvJuWRmecx.png" alt="https://i.loli.net/2020/11/13/KnazqhvJuWRmecx.png"></p><p>题三示意图</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题四</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/13/W81LwgATeqfKl5p.png" alt="https://i.loli.net/2020/11/13/W81LwgATeqfKl5p.png"></p><p>题四示意图</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题五</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> Foo)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/13/o8Qs3O4fGIiDh7V.png" alt="https://i.loli.net/2020/11/13/o8Qs3O4fGIiDh7V.png"></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype.n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A()  <span class="comment">// 到这里b可以通过__proto__访问到1</span></span><br><span class="line"></span><br><span class="line">A.prototype = &#123;  <span class="comment">// 这一步很关键，构造函数的原型重新赋值，这样和原来的原型间的关系就切断了</span></span><br><span class="line">n: <span class="number">2</span>,</span><br><span class="line">m: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A()  <span class="comment">// 到这里c能访问到的就是新赋值后的原型上的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.n, b.m, c.n, c.m)  <span class="comment">// 1, undefined, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延伸一下</span></span><br><span class="line">如果把 <span class="keyword">var</span> b = <span class="keyword">new</span> A() 放在 A.prototype = &#123;<span class="attr">n</span>:<span class="number">2</span>, <span class="attr">m</span>:<span class="number">3</span>&#125; 后面，那么得到的结果就是重新赋值后的值 <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>；</span><br><span class="line">上面b.n, b.m 结果之所以是<span class="number">1</span>, <span class="literal">undefined</span>，是因为它是prototype重新赋值前的值，和后面没关系</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 在 Object 的 prototype 上添加 a 方法，可以在上面的关系图上找到 Object.prototype 在哪里</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 在 Function 的 prototype 上添加 b 方法，可以在上面的关系图上找到 Function.prototype 在哪里</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = F()  <span class="comment">// 创建实例对象</span></span><br><span class="line">f.a()  <span class="comment">// 注释1：通过小 f 调用，说明是使用实例对象进行调用，如果本身没找到就通过 a()，那么就会通过 f 的隐式原型属性向上查找 f.__proto__</span></span><br><span class="line">f.b()  <span class="comment">// 注释2：在 __proto__ 上找不到 b() b is not a function</span></span><br><span class="line">F.a()  <span class="comment">// 注释3：特别注意一下，这里是通过 F 调用 a()，说明现在是把 F 当作是实例对象使用，这时就可以通过 F 的 __proto__ 原型链一起向上查找</span></span><br><span class="line">F.b()  <span class="comment">// 同注释3意思</span></span><br></pre></td></tr></table></figure><p>注释1图解，通过__proto__一直向上查找，打到了a()</p><p><img src="https://i.loli.net/2020/11/13/2oSlOWDP6eIXJ8N.png" alt="https://i.loli.net/2020/11/13/2oSlOWDP6eIXJ8N.png"></p><p>注释2示意图</p><p><img src="https://i.loli.net/2020/11/13/5lGd8vusahLpKCo.png" alt="https://i.loli.net/2020/11/13/5lGd8vusahLpKCo.png"></p><p>注释3/4示意图</p><p><img src="https://i.loli.net/2020/11/13/xRhXdN5r1AcnIL9.png" alt="https://i.loli.net/2020/11/13/xRhXdN5r1AcnIL9.png"></p><p>总结：一定要弄清楚上面的关系图，这个非常关键，弄清楚了原型和原型链这一块就差不多了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数的-prototype-属性&quot;&gt;&lt;a href=&quot;#函数的-prototype-属性&quot; class=&quot;headerlink&quot; title=&quot;函数的 prototype 属性&quot;&gt;&lt;/a&gt;函数的 prototype 属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个&lt;stron</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://webw3c.github.io/categories/JavaScript/"/>
    
    
    <category term="原型" scheme="https://webw3c.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
    <category term="原型链" scheme="https://webw3c.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    <category term="prototype" scheme="https://webw3c.github.io/tags/prototype/"/>
    
    <category term="__proto__" scheme="https://webw3c.github.io/tags/proto/"/>
    
    <category term="constructor" scheme="https://webw3c.github.io/tags/constructor/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB教程</title>
    <link href="https://webw3c.github.io/2019/02/20/MongoDB%E6%95%99%E7%A8%8B/"/>
    <id>https://webw3c.github.io/2019/02/20/MongoDB%E6%95%99%E7%A8%8B/</id>
    <published>2019-02-19T16:15:33.000Z</published>
    <updated>2020-09-25T07:47:10.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h2><p>启动数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod</span><br></pre></td></tr></table></figure><p>进入 mongo 命令环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>显示所有数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><p>使用某个数据库，如果当前不存在这个数据库的话会自动新建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称</span><br></pre></td></tr></table></figure><p>显示数据库内的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure><p>当前在哪个库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure><p>CRUD操作 可查看<a href="https://docs.mongodb.com/manual/crud/">官网文档</a></p><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>数据集合和插入数据，比如当前在 test01 数据库中。<br>插入数据会自动生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use test01     &#x2F;&#x2F; 如果当前没有 test01 数据库则会自动新建  </span><br><span class="line">show dbs       &#x2F;&#x2F; 如果 test01 是空白的，使用这个命令 test01 不会显示在结果列表中，必须不是空的才能显示  </span><br><span class="line">db.user.insert(&#123;&quot;name&quot;:&quot;PAN&quot;, &quot;age&quot;:&quot;18&quot;, &quot;job&quot;:&quot;web engineer&quot;&#125;)   &#x2F;&#x2F; 在 test01 中插入一个名为 user 的集合  </span><br><span class="line">db.user.insert(&#123;&quot;name&quot;:&quot;TING&quot;, &quot;age&quot;:&quot;16&quot;, &quot;job&quot;:&quot;seo manerge&quot;&#125;)   &#x2F;&#x2F; 再插入一条数据  </span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.user.find()    &#x2F;&#x2F; 查找 user 中的所有数据，这样就可以查看刚刚上面添加的那两条数据了</span><br><span class="line">db.user.find().count()  &#x2F;&#x2F; 长度</span><br><span class="line">db.user.findOne() &#x2F;&#x2F; 查找集合中符合条件的第一条数据</span><br><span class="line">&#x2F;&#x2F; db.user.findOnd(&#123;age:18&#125;).name</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>db.集合.updata({条件查询}, {修改})</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.update(&#123;&quot;name&quot;:&quot;YU&quot;&#125;,&#123;&quot;name&quot;:&quot;YONGYU&quot;, &quot;age&quot;:&quot;19&quot;&#125;)  &#x2F;&#x2F; 需要注意修改的新对象会直接覆盖原来的旧的对象。如果是需要修改指定的属性而不是替换旧对象，参考下面关于updata修改器的教程</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>db.集合.remove({条件})</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.remove(&#123;&quot;name&quot;:&quot;001&quot;&#125;)</span><br></pre></td></tr></table></figure><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><p>db.collection.drop()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test01.drop()  &#x2F;&#x2F; 返回 true 表示成功</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>db.dropDatabase()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h2 id="二、用JS写mongo语句"><a href="#二、用JS写mongo语句" class="headerlink" title="二、用JS写mongo语句"></a>二、用JS写mongo语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var userName &#x3D; &quot;TINGER&quot;; &#x2F;&#x2F; 定义用户名</span><br><span class="line">var timeStamp &#x3D; Date.parse(new Date()); &#x2F;&#x2F; 定义时间戳</span><br><span class="line">var jsonDatabase &#x3D; &#123;&quot;username&quot;: userName, &quot;loginTime&quot;: timeStamp&#125; &#x2F;&#x2F; 要插入的数据</span><br><span class="line">var db &#x3D; connect(&#39;test01&#39;);  &#x2F;&#x2F; 链接 test01 数据库</span><br><span class="line">db.user.insert(jsonDatabase); &#x2F;&#x2F; user 集合插入数据</span><br><span class="line"></span><br><span class="line">print(&#39;[log]:: print success!&#39;);</span><br></pre></td></tr></table></figure><h2 id="三、批量插入"><a href="#三、批量插入" class="headerlink" title="三、批量插入"></a>三、批量插入</h2><p>如果是3.2以前版本则需要使用 batchInsert()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br><span class="line">use test02</span><br><span class="line">db.test02.insert([&#123;&quot;_id&quot;:1&#125;,&#123;&quot;_id&quot;:2&#125;,&#123;&quot;_id&quot;:3&#125;])</span><br><span class="line">db.test02.find()    &#x2F;&#x2F; 查看插入结果</span><br></pre></td></tr></table></figure><p>插入性能测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var startTime &#x3D; (new Date()).getTime();</span><br><span class="line">var db &#x3D; connect(&#39;test02&#39;); &#x2F;&#x2F; 链接数据库</span><br><span class="line">var tempArr &#x3D; [];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环插入（不建议）</span><br><span class="line">&#x2F;&#x2F; for(let i&#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;   db.user.insert(&#123;num:1&#125;)</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 性能优化</span><br><span class="line">for(let i&#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">  tempArr.push(&#123;num:1&#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.user.insert(tempArr);</span><br><span class="line"></span><br><span class="line">var runTime &#x3D; (new Date()).getTime() - startTime;</span><br><span class="line"></span><br><span class="line">print(&#39;[log]:: runtime is &#39;+runTime+&#39;ms&#39;);</span><br></pre></td></tr></table></figure><h2 id="四、update-修改器"><a href="#四、update-修改器" class="headerlink" title="四、update 修改器"></a>四、update 修改器</h2><p>$set 修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;age&quot;:20&#125;&#125;) &#x2F;&#x2F; 修改 age</span><br><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;skill.s1&quot;:&quot;Excel&quot;&#125;&#125;)  &#x2F;&#x2F; 修改嵌套的s1。 skill.s1</span><br></pre></td></tr></table></figure><p>$unset 删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;,&#123;&quot;$unset&quot;:&#123;&quot;age&quot;:&#39;&#39;&#125;&#125;)  &#x2F;&#x2F; 删除age年龄。age 的值随便写，$unset 时只关心 key</span><br><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;age&quot;:20&#125;&#125;)  &#x2F;&#x2F; 重新添加 age。$set 当修改的属性为空时会自己添加</span><br></pre></td></tr></table></figure><p>$inc 对数字进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;,&#123;&quot;$inc&quot;:&#123;&quot;age&quot;:-2&#125;&#125;)  &#x2F;&#x2F; age 由原来的值减2</span><br></pre></td></tr></table></figure><p>multi选项，有 true 和 false 两个值。默认 false，为 true 时即所有项都添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&#125;,&#123;&quot;$set&quot;:&#123;&quot;aihao&quot;:[]&#125;&#125;, &#123;multi:true&#125;)</span><br></pre></td></tr></table></figure><p>upsert $set upsert 为 true 添加新项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;CUI&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;aihao&quot;:[]&#125;&#125;, &#123;upsert:true&#125;)  &#x2F;&#x2F; 如果 CUI 原来不存在，必须 upsert 为 true 才能添加到集合中</span><br></pre></td></tr></table></figure><h2 id="五、update数组修改器"><a href="#五、update数组修改器" class="headerlink" title="五、update数组修改器"></a>五、update数组修改器</h2><p>$push 追加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;,&#123;$push:&#123;&quot;aihao&quot;:&quot;shoping&quot;&#125;&#125;)  &#x2F;&#x2F; 在 aihao 项数组中添加 shoping</span><br></pre></td></tr></table></figure><p>$ne 查找是否存在。没有则修改，有则不修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;PAN&quot;, &quot;aihao&quot;:&#123;$ne:&quot;palygame&quot;&#125;&#125;, &#123;$push:&#123;&quot;aihao&quot;:&quot;Game&quot;&#125;&#125;) &#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>$addToSet 查找是否存在，不存在就 push，$ne 的升级版，工作用使用更多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;, &#123;$addToSet:&#123;&quot;aihao&quot;:&quot;跳舞&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$each 批量追加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;唱歌&#39;, &#39;跳舞&#39;, &#39;读书&#39;];</span><br><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;, &#123;$addToSet:&#123;&quot;aihao&quot;:&#123;$each:arr&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$pop 删除。1 删除末位，-1删除首位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;, &#123;$pop:&#123;&quot;aihao&quot;:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>数组定位修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.update(&#123;&quot;name&quot;:&quot;TING&quot;&#125;, &#123;$set:&#123;&quot;aihao.1&quot;:&quot;画画&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="六、修改的状态返回与安全"><a href="#六、修改的状态返回与安全" class="headerlink" title="六、修改的状态返回与安全"></a>六、修改的状态返回与安全</h2><p>runCommand 是数据库运行命令的执行器，执行命令首选就要使用它，因为它在Shell和驱动程序间提供了一致的接口。（几乎操作数据库的所有操作，都可以使用runCommand来执行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand():</span><br><span class="line">&#x2F;&#x2F; 例如</span><br><span class="line">db.runCommand(&#123;getLastError:1&#125;&#125;):  &#x2F;&#x2F;getLastError:1 :表示返回功能错误，这里的参数很多，如果有兴趣请自行查找学习，这里不作过多介绍</span><br><span class="line">db.runCommand(&#123;ping:1&#125;&#125;):  &#x2F;&#x2F; 查看数据库链接是否成功</span><br></pre></td></tr></table></figure><p>findAndModify<br>findAndModify 属性值  </p><ol><li>query: 要查询的条件/文档</li><li>sort: 进行排序</li><li>remove：[boolean]是否删除查找到的文档，值填写true，可以删除。</li><li>new:[boolean]返回更新前的文档还是更新后的文档。</li><li>fields：需要返回的字段</li><li>upsert：没有这个值是否增加。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myModify &#x3D; &#123;</span><br><span class="line">  findAndModify: &quot;user&quot;,</span><br><span class="line">  query: &#123;name: &quot;PAN&quot;&#125;,</span><br><span class="line">  update: &#123;$set:&#123;age:20&#125;&#125;,</span><br><span class="line">  new: true</span><br><span class="line">&#125;</span><br><span class="line">var resultMsg &#x3D; db.runCommand(myModify)</span><br><span class="line">printjson(resultMsg)  &#x2F;&#x2F; 表示以json对象的格式输出到控制台</span><br></pre></td></tr></table></figure><p>返回状态结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;lastErrorObject&quot; : &#123;</span><br><span class="line">        &quot;updatedExisting&quot; : true, &#x2F;&#x2F; 成功</span><br><span class="line">        &quot;n&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;value&quot; : &#123;  &#x2F;&#x2F; 返回修改后的结果</span><br><span class="line">        &quot;_id&quot; : ObjectId(&quot;5c6d1bac1c8ca3a357fdf9a7&quot;),</span><br><span class="line">        &quot;name&quot; : &quot;PAN&quot;,</span><br><span class="line">        &quot;age&quot; : 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、查询：find的不等修饰符"><a href="#七、查询：find的不等修饰符" class="headerlink" title="七、查询：find的不等修饰符"></a>七、查询：find的不等修饰符</h2><p>简单查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;&quot;skill.skillOne&quot;:&quot;HTML+CSS&quot;&#125;)</span><br></pre></td></tr></table></figure><p>筛选字段<br>第二个参数控制显示哪些字段。示例：显示 name 和 skill.skillOne 字段，隐藏 _id 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;&quot;skill.skillOne&quot;:&quot;HTML+CSS&quot;&#125;,&#123;name:true,&quot;skill.skillOne&quot;:true,_id:false&#125;)</span><br></pre></td></tr></table></figure><p>不等修饰符<br>小于($lt):  英文全称less-than<br>小于等于($lte)：英文全称less-than-equal<br>大于($gt):  英文全称greater-than<br>大于等于($gte):  英文全称greater-than-equal<br>不等于($ne):英文全称not-equal 我们现在要查找一下，公司内年龄小于30大于25岁的人员。看下面的代码。<br>示例：查询年龄大于等于 25，小于等于 30 的人  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;&quot;age&quot;:&#123;$gte:25,$lte:30&#125;&#125;,&#123;name:true,&quot;skill.skillOne&quot;:true,_id:false,age:true&#125;)</span><br></pre></td></tr></table></figure><p>查找日期<br>示例：查找日期大于2018-01-01的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var regTime &#x3D; new Date(&quot;01&#x2F;01&#x2F;2018&quot;);</span><br><span class="line">db.company.find(&#123;&quot;regeditTime&quot;:&#123;$gt:regTime&#125;&#125;,&#123;name:true,&quot;skill.skillOne&quot;:true,_id:false,age:true,regeditTime:true&#125;)</span><br></pre></td></tr></table></figure><h2 id="八、查询：find的多条件查询"><a href="#八、查询：find的多条件查询" class="headerlink" title="八、查询：find的多条件查询"></a>八、查询：find的多条件查询</h2><p>$in修饰符，一键多值，注意 $in 的值是一个数组<br>示例：查找年龄等于 25 和 33 岁的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;&quot;age&quot;:&#123;$in:[25,33]&#125;&#125;,&#123;name:1,&quot;skill.skillOne&quot;:1,_id:0,age:1&#125;)</span><br></pre></td></tr></table></figure><p>$in修饰符，和 $in 相反，就是不包含查询条件的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;&quot;age&quot;:&#123;$nin:[25,33]&#125;&#125;,&#123;name:1,&quot;skill.skillOne&quot;:1,_id:0,age:1&#125;)</span><br></pre></td></tr></table></figure><p>$or，或者，类似JS中的或运算 ||<br>示例：查找年龄大于行于30或者技能会PHP的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;$or:[</span><br><span class="line">  &#123;age:&#123;$gte:30&#125;&#125;,</span><br><span class="line">  &#123;&quot;skill.skillThree&quot;:&quot;PHP&quot;&#125;</span><br><span class="line">]&#125;,&#123;name:1,&quot;skill.skillThree&quot;:1,_id:0,age:1&#125;)</span><br></pre></td></tr></table></figure><p>$and，并且，类似JS中的或运算 &amp;&amp;<br>示例：查找年龄大于行于30并且技能会PHP的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.company.find(&#123;$and:[</span><br><span class="line">  &#123;age:&#123;$gte:30&#125;&#125;,</span><br><span class="line">  &#123;&quot;skill.skillThree&quot;:&quot;PHP&quot;&#125;</span><br><span class="line">]&#125;,&#123;name:1,&quot;skill.skillThree&quot;:1,_id:0,age:1&#125;)</span><br></pre></td></tr></table></figure><p>$not修饰符<br>查找除年龄大于20岁，小于30岁的人员信息。需要注意的是$not修饰符不能应用在条件语句中，只能在外边进行查询使用。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;</span><br><span class="line">    age:&#123;</span><br><span class="line">        $not:&#123;</span><br><span class="line">            $lte:30,</span><br><span class="line">            $gte:20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;name:1,&quot;skill.skillOne&quot;:1,age:1,_id:0&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="九、查询：find数组查询"><a href="#九、查询：find数组查询" class="headerlink" title="九、查询：find数组查询"></a>九、查询：find数组查询</h2><p>基本数组查询<br>示例：查询兴趣(interest)中有画画的人员  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;interest:&#39;画画&#39;&#125;,&#123;name:1,interest:1,_id:0&#125;)</span><br><span class="line">&#x2F;&#x2F; 如果画画加了数组的中括则表示要完全匹配条件，例如以下示例则表示要完全匹配有画画和看电影的</span><br><span class="line">db.workmate.find(&#123;interest:[&#39;画画&#39;,&#39;看电影&#39;]&#125;,&#123;name:1,interest:1,_id:0&#125;)</span><br></pre></td></tr></table></figure><p>$all 数组多项查询<br>示例：查询兴趣中同时存在画画和看电影两项的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;interest:&#123;$all:[&quot;画画&quot;,&quot;看电影&quot;]&#125;&#125;,&#123;name:1,interest:1,_id:0&#125;)</span><br></pre></td></tr></table></figure><p>$in 数组的或查询<br>类似JS的或运算，示例：查询兴趣中有画画或者看电影一项的结果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;interest:&#123;$in:[&quot;画画&quot;,&quot;看电影&quot;]&#125;&#125;,&#123;name:1,interest:1,_id:0&#125;)</span><br></pre></td></tr></table></figure><p>$size 数组个数查询<br>示例：显示兴趣项长度为3的项  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;interest:&#123;$size:3&#125;&#125;,&#123;name:1,interest:1,_id:0&#125;)</span><br></pre></td></tr></table></figure><p>$slice 控制显示长度<br>示例：只显示兴趣数组前两项，也也接受负数，如果-1表示最后一项  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;interest:&#123;$size:3&#125;&#125;,&#123;name:1,interest:&#123;$slice:2&#125;,_id:0&#125;)</span><br></pre></td></tr></table></figure><h2 id="十、查询：find参数"><a href="#十、查询：find参数" class="headerlink" title="十、查询：find参数"></a>十、查询：find参数</h2><p>find查询包含以下几个参数query, fields, limit, skip, batchSize, options，前面的示例用的一直都是query和fields<br>query：这个就是查询条件，MongoDB默认的第一个参数。<br>fields：（返回内容）查询出来后显示的结果样式，可以用true和false控制是否显示。<br>limit：返回的数量，后边跟数字，控制每次查询返回的结果数量。<br>skip:跳过多少个显示，和limit结合可以实现分页。<br>sort：排序方式，从小到大排序使用1，从大到小排序使用-1  </p><p>示例：limit显示4条，跳过0条  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;).limit(4).skip(0)</span><br><span class="line">如果要做分页可以如下编写</span><br><span class="line">db.workmate.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;).limit(4).skip(0)  &#x2F;&#x2F; 第一页，每页显示4条，跳过0条数据</span><br><span class="line">db.workmate.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;).limit(4).skip(4)  &#x2F;&#x2F; 第二页，每页显示4条，跳过4条数据</span><br><span class="line">db.workmate.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;).limit(4).skip(8)  &#x2F;&#x2F; 第三页，每页显示4条，跳过8条数据</span><br></pre></td></tr></table></figure><p>示例：对年龄排序，1表示从小到大排序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;).limit(4).skip(0).sort(&#123;age:1&#125;)</span><br></pre></td></tr></table></figure><h2 id="十一、索引入门"><a href="#十一、索引入门" class="headerlink" title="十一、索引入门"></a>十一、索引入门</h2><p>普通查询性能测试  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var startTime &#x3D; (new Date).getTime();</span><br><span class="line"></span><br><span class="line">var db &#x3D; connect(&#39;test02&#39;);</span><br><span class="line">var rs &#x3D; db.randomInfo.find(&#123;username:&#39;dnaugkj&#39;&#125;);</span><br><span class="line">rs.forEach(rs&#x3D;&gt;&#123;printjson(rs)&#125;) </span><br><span class="line"></span><br><span class="line">var runTime &#x3D; (new Date).getTime() - startTime;</span><br><span class="line">print(&#39;[SUCCESS]This run time is:&#39;+runTime+&#39;ms&#39;);</span><br></pre></td></tr></table></figure><p>示例结果，大概需要600-800毫秒左右，具体结果和机器有一定关系。  </p><p>查看索引  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">db.randomInfo.getIndexes()  &#x2F;&#x2F; randomInfo 为 collections 名称</span><br><span class="line">&#x2F;&#x2F; 查询结果</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;v&quot; : 2,</span><br><span class="line">        &quot;key&quot; : &#123;</span><br><span class="line">            &quot;_id&quot; : 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot; : &quot;_id_&quot;,</span><br><span class="line">        &quot;ns&quot; : &quot;test02.randomInfo&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;v&quot; : 2,</span><br><span class="line">        &quot;key&quot; : &#123;</span><br><span class="line">            &quot;username&quot; : 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot; : &quot;username_1&quot;,</span><br><span class="line">        &quot;ns&quot; : &quot;test02.randomInfo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>建立索引<br>MongoDB 最多只能建立 64 个索引，索引会消耗硬盘和内存资源。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.randomInfo.ensureIndex(&#123;username:1&#125;)</span><br><span class="line">&#x2F;&#x2F; 如果运行正确，建立之后使用 getIndexes 即可查看</span><br></pre></td></tr></table></figure><p>建立索引之后再运行一下上面普通查询的代码会发现查询速度会极大提升，约5-10毫秒左右</p><p>删除索引  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.randomInfo.dropIndex(&#39;username_1&#39;);  &#x2F;&#x2F; 注意值不是 key 值，而是 name 值</span><br></pre></td></tr></table></figure><p>查看运行时间  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.randomInfo.find(&#123;username:&#39;dnaugkj&#39;&#125;).explain(&quot;executionStats&quot;);</span><br></pre></td></tr></table></figure><h2 id="十二、复合索引"><a href="#十二、复合索引" class="headerlink" title="十二、复合索引"></a>十二、复合索引</h2><p>数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。<br>查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。<br>数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。<br>把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。  </p><p>复合索引就是两个以上的索引  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var startTime &#x3D; (new Date).getTime();</span><br><span class="line"></span><br><span class="line">var db &#x3D; connect(&#39;test02&#39;);</span><br><span class="line">var rs &#x3D; db.randomInfo.find(&#123;username:&#39;dnaugkj&#39;, randNum0:940739&#125;);</span><br><span class="line">rs.forEach(rs&#x3D;&gt;&#123;printjson(rs)&#125;) </span><br><span class="line"></span><br><span class="line">var runTime &#x3D; (new Date).getTime() - startTime;</span><br><span class="line">print(&#39;[SUCCESS]This run time is:&#39;+runTime+&#39;ms&#39;);</span><br></pre></td></tr></table></figure><p>指定索引查询（hint）<br>使用 hint() 方法指定索引优先查询  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...e</span><br><span class="line">var rs &#x3D; db.randomInfo.find(&#123;username:&#39;dnaugkj&#39;, randNum0:940739&#125;).hint(&#123;randNum0:1&#125;);  &#x2F;&#x2F; randNum0 优先查询</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="十四、全文索引"><a href="#十四、全文索引" class="headerlink" title="十四、全文索引"></a>十四、全文索引</h2><p>建立全文索引  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.ensureIndex(&#123;&quot;contextInfo&quot;:&quot;text&quot;&#125;)</span><br></pre></td></tr></table></figure><p>全文索引查找<br>查找时需要配合两个关键修改符<br>$text:表示要在全文索引中查东西。<br>$search:后边跟查找的内容。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;$text:&#123;$search:&quot;programmer&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>多词查询<br>示例：查询包含 drink 或者 life 的记录  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;$text:&#123;$search:&quot;drink life&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>可以用 - 来排队不需要的记录。示例：排队带有 drink 的记录项  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;$text:&#123;$search:&quot;-drink life&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>转义符  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">想搜索的是两个词（love PlayGame和drink）</span><br><span class="line">db.info.find(&#123;$text:&#123;$search:&quot;\&quot;love PlayGame\&quot; drink&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="十五、管理-用户的创建、删除与修改"><a href="#十五、管理-用户的创建、删除与修改" class="headerlink" title="十五、管理:用户的创建、删除与修改"></a>十五、管理:用户的创建、删除与修改</h2><p>创建用户首先要进入 admin 库，show collections 只有 version 一个集合  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br><span class="line">use admin</span><br><span class="line">show collections</span><br></pre></td></tr></table></figure><p>创建用户<br>使用 createUser 创建数据库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">  user:&quot;pan&quot;,   &#x2F;&#x2F; 用户名</span><br><span class="line">  pwd:&quot;123456&quot;, &#x2F;&#x2F; 密码</span><br><span class="line">  customData:&#123;  &#x2F;&#x2F; 个性信息</span><br><span class="line">    name:&quot;潘&quot;,</span><br><span class="line">    age:18</span><br><span class="line">  &#125;,</span><br><span class="line">  roles:[  &#x2F;&#x2F; 配置权限</span><br><span class="line">    &#123;</span><br><span class="line">      role:&#39;readWrite&#39;,  &#x2F;&#x2F; test02 有读写权限</span><br><span class="line">      db:&#39;test02&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;read&#39; &#x2F;&#x2F; 其他所有库只有吟诗权限</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>内置角色<br>数据库用户角色：read、readWrite；<br>数据库管理角色：dbAdmin、dbOwner、userAdmin;<br>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；<br>备份恢复角色：backup、restore；<br>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase<br>超级用户角色：root<br>内部角色：__system  </p><p>查找用户信息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.system.users.find()</span><br></pre></td></tr></table></figure><p>删除用户  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.system.users.remove(&#123;user:&quot;pan&quot;&#125;)</span><br></pre></td></tr></table></figure><h2 id="十六、备份和还原"><a href="#十六、备份和还原" class="headerlink" title="十六、备份和还原"></a>十六、备份和还原</h2><p>备份  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongodump</span><br><span class="line">    --host 127.0.0.1</span><br><span class="line">    --port 27017</span><br><span class="line">    --out D:&#x2F;databack&#x2F;backup</span><br><span class="line">    --collection myCollections</span><br><span class="line">    --db test</span><br><span class="line">    --username username</span><br><span class="line">    --password password</span><br><span class="line">mongodump --host 127.0.0.1 --port 27017 --out &#x2F;Users&#x2F;panyongyu&#x2F;Documents&#x2F;study&#x2F;mongodb&#x2F;backup</span><br></pre></td></tr></table></figure><p>还原</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mongorestore</span><br><span class="line">    --host 127.0.0.1</span><br><span class="line">    --port 27017</span><br><span class="line">    --username username</span><br><span class="line">    --password password</span><br><span class="line">    &lt;path to the backup&gt;</span><br><span class="line">mongorestore --host 127.0.0.1 --port 27017 --out &#x2F;Users&#x2F;panyongyu&#x2F;Documents&#x2F;study&#x2F;mongodb&#x2F;backup</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、基本命令&quot;&gt;&lt;a href=&quot;#一、基本命令&quot; class=&quot;headerlink&quot; title=&quot;一、基本命令&quot;&gt;&lt;/a&gt;一、基本命令&lt;/h2&gt;&lt;p&gt;启动数据库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="编程" scheme="https://webw3c.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="MongoDB" scheme="https://webw3c.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>gitignore不起作用</title>
    <link href="https://webw3c.github.io/2019/02/10/gitignore%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>https://webw3c.github.io/2019/02/10/gitignore%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</id>
    <published>2019-02-10T02:28:09.000Z</published>
    <updated>2020-09-25T07:01:03.179Z</updated>
    
    <content type="html"><![CDATA[<p>今天在项目时遇到一个问题，就是加入 ignore 的文件并不起作用，.gitignore 中已经标明忽略的文件目录下的文件，git push 的时候还会出现在 push 的目录中，原因是因为在 git 忽略目录中，新建的文件在 git 中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在 .gitignore 中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行 git push，这样就不会出现忽略的文件了。git 清除本地缓存命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;update .gitignore&#39;</span><br></pre></td></tr></table></figure><p>完美！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在项目时遇到一个问题，就是加入 ignore 的文件并不起作用，.gitignore 中已经标明忽略的文件目录下的文件，git push 的时候还会出现在 push 的目录中，原因是因为在 git 忽略目录中，新建的文件在 git 中会有缓存，如果某些文件已经被纳入了版</summary>
      
    
    
    
    <category term="编程" scheme="https://webw3c.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Git" scheme="https://webw3c.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用教程</title>
    <link href="https://webw3c.github.io/2019/02/06/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://webw3c.github.io/2019/02/06/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2019-02-06T06:07:15.000Z</published>
    <updated>2020-09-25T06:53:36.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>初初始化仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加文件，把文件添加到缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#39;提交日志说明&#39;</span><br></pre></td></tr></table></figure><p>查看当前仓库状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看修改了什么内容，就是文件对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>查看最近提交的版本。版本号是用SHA1计算出的十六进制数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline</span><br></pre></td></tr></table></figure><p>执行回滚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>查看记录你的操作命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><h2 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h2><p><img src="https://i.loli.net/2020/09/25/EhtJQFWSmDcewVA.png" alt="EhtJQFWSmDcewVA"></p><h2 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h2><p>工作区中的隐藏目录 .git 就是 git 的版本库<br>Git的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支 master，以及指向  master的一个指针叫 HEAD。</p><p><img src="https://i.loli.net/2020/09/25/vy4m62bT1sBpkFI.png" alt="vy4m62bT1sBpkFI"></p><p>给版本库添加文件分两步执行 git add 和 git commit</p><ul><li><code>git add</code> 就是把修改文件添加到版本库缓存区;</li><li><code>git commit</code> 实际上就是把暂存区的所有内容提交到当前分支。</li></ul><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>每次修改，如果不用git add到暂存区，那就不会加入到commit中。<br>就是说 git commit 不提交暂存区以外的修改。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ol><li>直接丢弃工作区的修改时，用命令git checkout – file（这种情况是还没提交到暂存的情况）</li><li>添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>如果直接在资源管理器删除了文件，或者用rm命令（rm file）删除了文件分两种情况：<br>先用 git stauts 命令查看下当前版本库状态</p><ol><li><p>一种情况是你确实想删除文件，那么你可以执行以下操作：<br>git rm file<br>git commit -m ‘删除xxx文件’<br>那么文件就从版本库中被删除</p></li><li><p>第二种情况是你误删了文件，不必担心你可以使用 git checkout – file 恢复文件到工作区。<br>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p></li></ol><br/><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="一、添加远程仓库"><a href="#一、添加远程仓库" class="headerlink" title="一、添加远程仓库"></a>一、添加远程仓库</h2><ol><li><p>先<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000">生成</a>一个公钥 </p></li><li><p>生成的公钥复制粘贴到 github。setting –&gt; SSH and GPG keys</p></li><li><p>关联本地仓库和Github上的仓库<br>git remote add origin <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a>:webw3c/learngit.git 注意要是自己的github账户<br>如果此步出现 fatal: remote origin already exists. 提示，则先执行一次 $ git remote rm origin 命令</p></li><li><p>git push -u origin master<br>如果此步出现<br>! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed to push some refs to ‘git@github.com:blueWeekend/blue.git’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Merge the remote changes (e.g. ‘git pull’)<br>hint: before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.<br>则需要先把远程仓库 pull 下来，然后强制push<br>git push -u origin master -f </p></li></ol><p><img src="https://i.loli.net/2020/09/25/vculNj46LTCDf2m.png" alt="vculNj46LTCDf2m"></p><br/><h2 id="二、从远程仓库克隆"><a href="#二、从远程仓库克隆" class="headerlink" title="二、从远程仓库克隆"></a>二、从远程仓库克隆</h2><p>实际项目更多的应该是先创建远程库，然后，从远程库克隆。<br>git clone <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:你的用户名/learngit.git</p><br/># 分支管理## 一、创建与合并分支master 是主分支，HEAD是指向当前分支的![d3PCZogSAHu97ai](https://i.loli.net/2020/09/25/d3PCZogSAHu97ai.png)<p>示例：<br>创建dev分支，然后切换到dev分支：<br>git checkout -b dev<br>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令<br>git branch dev    // 创建<br>git checkout dev    // 切换。git checkout 是切换命令，可以切换到任意  分支，如：git checkout master  </p><p>git branch 命令可以查看当前分支。些命令会列出所有分支，并在当前分支前标一 * 号  </p><p>PS：有时在子分支修改内容后切换回master分支会发现新修改的内容不见了，是因式修改的内容并不是在master分支上修改提交的，而是在子分支上。所以只要合并到master分支即可。  </p><p>git merge命令用于合并指定分支到当前分支。  </p><p>git branch -d dev    // 删除指定分支  </p><p>git push origin 分支名称    // 提交一个新的分支到远程仓库  </p><p>分支命令小结：<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name>  </p><br/><h2 id="二、解决冲突"><a href="#二、解决冲突" class="headerlink" title="二、解决冲突"></a>二、解决冲突</h2><p>一般手动解决后再提交即可<br>git status 也可以查看冲突情况<br>git log 命令可以查看分支的合并情况<br>git log –graph –pretty=oneline –abbrev-commit  </p><br/><h2 id="三、分支管理策略"><a href="#三、分支管理策略" class="headerlink" title="三、分支管理策略"></a>三、分支管理策略</h2><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>干活都在dev分支上，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；<br>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。<br>所以，团队合作的分支看起来就像这样：</p><p><img src="https://i.loli.net/2020/09/25/PN9fsLRmrd1S2TU.png" alt="PN9fsLRmrd1S2TU"></p><br/><h2 id="四、BUG分支"><a href="#四、BUG分支" class="headerlink" title="四、BUG分支"></a>四、BUG分支</h2><p>当你工作到一半而无法先提交当前分支时，可以使用 <code>git stash</code> 先把未完成未提交的分支工作状态保存起来，以便后面恢复继续工作。<br>当你要恢复之前未完成的状态时，使用 <code>git stash list</code> 查看未保存状态的列表（可能有多个），恢复：<br><code>git stash apply</code> 恢复但不删除stash内容，你需要使用 <code>git stash drop</code> 来删除；<br><code>git stash pop</code> 恢复的同时把 <code>stash</code> 内容也删了<br><code>git stash apply stash@&#123;0&#125;</code> 恢复指定的 stash  </p><br/><h2 id="五、feature分支"><a href="#五、feature分支" class="headerlink" title="五、feature分支"></a>五、feature分支</h2><p>和BUG分支类似。<br>强制删除一个未合并的分支可以使用大写D执行：<br>git branch -D feature-one  </p><br/><h2 id="六、多人协作"><a href="#六、多人协作" class="headerlink" title="六、多人协作"></a>六、多人协作</h2><ol><li>查看远程库信息，使用 <code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用 <code>git pull</code>，如果有冲突，要先处理冲突。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;p&gt;初初始化仓库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="编程" scheme="https://webw3c.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Git" scheme="https://webw3c.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>非微信官方网页，继续访问将转换成手机预览模式</title>
    <link href="https://webw3c.github.io/2019/01/24/wechatnoaccess/"/>
    <id>https://webw3c.github.io/2019/01/24/wechatnoaccess/</id>
    <published>2019-01-24T02:03:36.000Z</published>
    <updated>2019-08-12T06:23:23.717Z</updated>
    
    <content type="html"><![CDATA[<p>你的网站如果没有在公众后台设置JS接口安全域名的话会提示“非微信官方网页，继续访问将转换成手机预览模式”，所以呢先登录你的公众号后台设置一下，设置–&gt;公众号设置–&gt;功能设置–&gt;JS接口安全域名</p><p><img src="http://wx1.sinaimg.cn/large/889d1a94gy1fzhgbe2vcuj20vq09c74r.jpg" alt="image"></p><p><img src="http://wx2.sinaimg.cn/large/889d1a94gy1fzhghbt49vj21pa0r8q5q.jpg" alt="image"></p><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhglivs9vj21sm13i7at.jpg" alt="image"></p><p>点设置后弹窗你会看到几点要求，其中主要的是第二第三点，你的域名是要备案过的，另外需要把 MP_verify_9Ejr0IPEERUl7Xp8.txt 文件下载放至你的服务器或者空间根目录下，最后添加你的站点域名，如果通过 <a href="http://www.xxx.com/MP_verify_9Ejr0IPEERUl7Xp8.txt">www.xxx.com/MP_verify_9Ejr0IPEERUl7Xp8.txt</a> 能访问到这个文件，在添加域名之后一般是能保存成功的，会有相应的提示。</p><p>注：<br>1、如果还没备案的话提交备案到完成可能至少要六七天的时间估计，但也是不确定的具体要看相应的情况，而且备案完成后还需要等待1-3天才能查询得到你的备案信息。<br>2、因为我的只是个人订阅号，所以只有 JS接口安全域名这一项，如果是认证的账号还会有业务域名和网页授权域名。</p><p>添加成功后你的站点就能正常的在微信内打开了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你的网站如果没有在公众后台设置JS接口安全域名的话会提示“非微信官方网页，继续访问将转换成手机预览模式”，所以呢先登录你的公众号后台设置一下，设置–&amp;gt;公众号设置–&amp;gt;功能设置–&amp;gt;JS接口安全域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sin</summary>
      
    
    
    
    <category term="工具" scheme="https://webw3c.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="微信" scheme="https://webw3c.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
    <category term="公众号" scheme="https://webw3c.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 入门篇</title>
    <link href="https://webw3c.github.io/2019/01/22/nginxbase/"/>
    <id>https://webw3c.github.io/2019/01/22/nginxbase/</id>
    <published>2019-01-22T11:09:40.000Z</published>
    <updated>2020-09-25T06:50:58.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>支持高并发</li><li>内存消耗少</li><li>开源可商用</li></ol><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><strong>Mac 下安装</strong><br>1、安装 brew 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><p>2、安装 Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p>3、启动 Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>如果没有报错的话打开 <a href="http://localhost:8080/">http://localhost:8080</a> 就可以看到效果了。</p><p>配置文件所在目录 /usr/local/etc/nginx/nginx.conf</p><p>安装文件所在目录 /usr/local/Cellar/nginx</p><p><strong>Linux 下安装（本文后面的内容也主要是在 Centos 环境中演示）</strong><br>先安装一些服务器要用到的东西</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf pcre-devel make automake</span><br><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure><p>查看 yum 是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p>如果存在会如以下图示</p><p><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fzf7pigjyjj20mr08fabf.jpg" alt="image"></p><p>和官网的对比一下发现不是最新的，所以要增加 nginx 的 yum 源，输入以下命令新建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>并把以下内容粘贴进去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>因为我的是 centos 系统，版本是7.2，所以链接里面是 /centos/7，现在再运行一下检查命令就可以查看到最新 nginx 版本了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p>接着就是安装了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>安装完成后输入 <font color="#f60">nginx -v</font> 查看版本号，如果显示版本就表示安装成功了</p><p><img src="http://ws4.sinaimg.cn/large/889d1a94gy1fzf88dbsxnj20ng0e140b.jpg" alt="image"></p><h2 id="二、Nginx-配置文件解析"><a href="#二、Nginx-配置文件解析" class="headerlink" title="二、Nginx 配置文件解析"></a>二、Nginx 配置文件解析</h2><h2 id="三、启动、停止、重启等常用操作"><a href="#三、启动、停止、重启等常用操作" class="headerlink" title="三、启动、停止、重启等常用操作"></a>三、启动、停止、重启等常用操作</h2><p><strong>启动</strong><br>1、直接使用 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>2、使用 systemctl 命令，这个是 Linux 的服务启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p>有没有启动成功呢？可以输入以下命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure><p><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzfeh1ugvwj20nc02baab.jpg" alt="image"></p><p><strong>停止</strong><br>1、立即停止服务。这种方法无论进程是否在运行，都直接停止进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx  -s stop</span><br></pre></td></tr></table></figure><p>2、立即停止服务。这种方法相对没那么强硬，需要在进程完成当前工作后再停止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx  -s quit</span><br></pre></td></tr></table></figure><p>3、killall 直接杀死进程。如果上面的两个方法无效，可以试试这个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure><p>4、systemctl 停止。这个和启动方法中第二条类似，都是使用 Linux 的服务命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx.service</span><br></pre></td></tr></table></figure><p><strong>重启</strong><br>重启也是经常会用到的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><p><strong>重载配置文件</strong><br>有时修改了配置文件可以不用重启，直接重载配置文件就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><strong>查看端口号</strong><br>有时候需要查看哪些端口在运行，或者被占用了，可以使用 netstat 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure><h2 id="四、自定义错误页"><a href="#四、自定义错误页" class="headerlink" title="四、自定义错误页"></a>四、自定义错误页</h2><p><strong>自定义错误页</strong><br>网站发生错误时一般会返回相应的状态码，比如500、502、503等等，或者404页面。那这些对应的返回页面在 Nginx 里怎么配置呢。</p><p>进入 /etc/nginx/conf.d 目录 打开 default.conf 配置文件就可以作相应的修改了</p><p><img src="http://ws1.sinaimg.cn/large/889d1a94gy1fzfg3vng9pj20n5027aa3.jpg" alt="image"></p><p>添加404页面配置，当然你还要在网站根目录创建一个404.html页面才行</p><p><img src="http://wx1.sinaimg.cn/large/889d1a94gy1fzfged7tgjj20nu0i876t.jpg" alt="image"></p><p>其中 /404.html 也可以改成一个链接地址如： (<a href="https://pojian.xyz)[https://pojian.xyz]，这样当你访问为404状态时就会直接跳转到你配置的这个链接地址。">https://pojian.xyz)[https://pojian.xyz]，这样当你访问为404状态时就会直接跳转到你配置的这个链接地址。</a></p><p>最后还需要你执行重载配置文件或者重启服务器，再访问相应的页面就会看到对应的效果页。</p><h2 id="五、访问权限设置"><a href="#五、访问权限设置" class="headerlink" title="五、访问权限设置"></a>五、访问权限设置</h2><p><strong>指令优先级</strong><br>打开配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>在 location 里填写 deny 和 allow 配置信息，deny 和 allow 后面可以填写 ip 或者一个 ip 段，再或者 all，all 表示全部，比如这里我填写的是我本机的ip，allow 表示允许该 ip 的访问，接着重启 nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fzgkp66ohwj219e0dugmz.jpg" alt="image"></p><p>上面的配置表示只允许 113.118.186.11 进行访问，其他的IP是禁止访问</p><p><img src="http://ws2.sinaimg.cn/large/889d1a94gy1fzgl1ra9b1j21jg076jrr.jpg" alt="image"></p><p>如果上面的 allow 和 deny 位置互换一下呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deny all;</span><br><span class="line">allow 113.118.186.11;</span><br></pre></td></tr></table></figure><p>这里你会发再所有 ip 都不能访问了，这就说明了配置对顺序是有要求的，同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置。</p><p><strong>其他访问控制权限匹配</strong><br>有时权限控制会比上面的情况会多样一点，比如站点下的 images 文件是所有用户都可以访问的，而 admin 文件夹只有管理员才能访问，这时就需要 location 来配合实现了</p><h2 id="六、配置虚拟主机"><a href="#六、配置虚拟主机" class="headerlink" title="六、配置虚拟主机"></a>六、配置虚拟主机</h2><p><strong>基于端口号</strong><br>基于端口号配置多个虚拟主机，根据不同的端口号来访问不同的站点，原来就是监听端口号。</p><p>可以直接配置了主配置文件 etc/nginx/nginx.conf，也可以配在子配置文件目录下 etc/nginx/conf.d，这里拿配置在子文件做示例</p><p>etc/nginx/conf.d/default.conf 默认监听的是 <strong>80</strong> 端口，指向的目录是 /data/www</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhod50ihzj21660bct9n.jpg" alt="image"></p><p>现在我们配置添加一个新的虚拟主机，监听 <strong>8081</strong> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/8081.conf</span><br></pre></td></tr></table></figure><p>8081.conf 具体配置如下，监听的端口为 <strong>8081</strong>，指向的目录是 /data/www/8081，和 <strong>80</strong> 端口指向的目录不一样</p><p><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzhoi9spuxj216i04wdg7.jpg" alt="image"></p><p>这里需要你自己去新建一个 8081 目录和 index.html 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/www/8081</span><br><span class="line">vim /data/www/8081/index.html</span><br></pre></td></tr></table></figure><p>最后访问 xxx.com 和 xxx.com:8081 会访问到不同的站点，当然前提是你的域名已经解析到你的服务器，要不然的话就只能通过 ip 访问了 xxx.xxx.xx.xx 和 xxx.xxx.xx.xx:8081 访问。</p><p><strong>基于域名配置</strong></p><p>基于域名配置，我这里先说一个前提，就是你的域名已经成功解析到服务器。</p><p><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fzhosuczh6j21u2080jsw.jpg" alt="image"></p><p>下面开始配置 nginx</p><p>/etc/nginx/conf.d/default.conf 配置文件监听的是 <strong>80</strong> 端口，指向目录是 /data/www，注意看 server_name 改成域名地址</p><p><img src="http://wx2.sinaimg.cn/large/889d1a94gy1fzhobuxtkxj21660bcdgt.jpg" alt="image"></p><p>接着我们来配置另外一个虚拟站点 /etc/nginx/conf.d/8081.conf，注意了 这里监听我端口也是 <strong>80</strong> 端口，不是其他的端口号，但 server_name 和 root 目录跟上面的不一样</p><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhshp7dttj216405ogm3.jpg" alt="image"></p><p>这样当你访问 nginx.pojian.xyz 和 nginx2.pojian.xyz 时访问会是配置的不同的两个站点。</p><h2 id="七、反向代理"><a href="#七、反向代理" class="headerlink" title="七、反向代理"></a>七、反向代理</h2><p><strong>正向代理</strong><br>A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。</p><p>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com/">http://www.google.com</a>  时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。<br><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzittlk5sgj20zu0kq1kx.jpg" alt="image"></p><p><strong>反向代理</strong></p><p>大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。</p><p>反向代理隐藏了真实的服务端，当我们请求<a href="http://www.baidu.com/">www.baidu.com</a> 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a href="http://www.baidu.com/">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，具体访问哪台服务器Server是由Nginx来控制的，一般用来做负载均衡。</p><p><img src="http://ws2.sinaimg.cn/large/889d1a94gy1fzitu7g08oj20sk0nk7pb.jpg" alt="image"></p><p>两者的区别在于代理的对象不一样：<strong>正向代理代理的对象是客户端，反向代理代理的对象是服务端</strong></p><p><strong>最简单的反向代理</strong></p><p>下面就说一个最简单的反向代理配置，先打开我们前面配置的 8081 端口虚拟站点配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/8081.conf</span><br></pre></td></tr></table></figure><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhshp7dttj216405ogm3.jpg" alt="image"></p><p>原来的 root 和 index 不要了，换成一个 location 代理地址，看下图</p><p><img src="http://wx2.sinaimg.cn/large/889d1a94gy1fziv0a4rtyj21cs05udk2.jpg" alt="image"></p><p>这样当你访问 nginx2.pojian.xyz 的时候 nginx 会帮你反向代理到 <a href="https://pojian.xyz/">https://pojian.xyz</a> 这个地址上去，proxy_pass 一般是填写 ip，但填写域名也可以。</p><p><strong>其它一些较常用的反向代理指令</strong></p><ul><li>proxy_set_header: 在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</li><li>proxy_connect_timeout: 配置Nginx与后端代理服务器尝试建立连接的超时时间。</li><li>proxy_read_timeout: 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。</li><li>proxy_send_timeout: 配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。</li><li>proxy_redirect: 用于修改后端服务器返回的响应头中的Location和Refresh。</li></ul><h2 id="八、开启-Gzip-压缩"><a href="#八、开启-Gzip-压缩" class="headerlink" title="八、开启 Gzip 压缩"></a>八、开启 Gzip 压缩</h2><p>Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。</p><ul><li>gzip : 该指令用于开启或 关闭gzip模块。</li><li>gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。</li><li>gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li><li>gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。</li><li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。</li><li>gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0.</li><li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。</li><li>gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。</li></ul><p>最简单的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    .....</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types text/plain application/javascript text/css;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzixy8p8c4j21820eogsb.jpg" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;支持高并发&lt;/li&gt;
&lt;li&gt;内存消耗少&lt;/li&gt;
&lt;li&gt;开源可商用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;一、安装&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="编程" scheme="https://webw3c.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="nginx" scheme="https://webw3c.github.io/tags/nginx/"/>
    
    <category term="centos" scheme="https://webw3c.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac下SSH闲时自动断开的问题</title>
    <link href="https://webw3c.github.io/2019/01/22/macsshconnection/"/>
    <id>https://webw3c.github.io/2019/01/22/macsshconnection/</id>
    <published>2019-01-22T10:32:19.000Z</published>
    <updated>2019-01-22T10:53:31.152Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Mac 自带终端 SSH 连接服务器时，只要隔一小段时间不进行操作的话连接就会自动中断，造成了不好的体验。解决方法如下：</p><p>1、连接到你的服务器</p><p>2、编辑服务端配置文件 /etc/ssh/sshd_config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>添加以下两行配置代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 30</span><br><span class="line">ClientAliveCountMax 3</span><br></pre></td></tr></table></figure><p>3、编辑客户端配置文件 /etc/ssh/ssh_config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure><p>在 Host * 下面添加以下两行配置代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval 30</span><br><span class="line">ServerAliveCountMax 3</span><br></pre></td></tr></table></figure><p>4、断开SSH连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + d</span><br></pre></td></tr></table></figure><p>5、SSH 重连服务然后执行重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line">reboot 就是重启</span><br></pre></td></tr></table></figure><p>重启后可能需要等待1分钟左右才能重新连接上。</p><p>最后验证测试就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 Mac 自带终端 SSH 连接服务器时，只要隔一小段时间不进行操作的话连接就会自动中断，造成了不好的体验。解决方法如下：&lt;/p&gt;
&lt;p&gt;1、连接到你的服务器&lt;/p&gt;
&lt;p&gt;2、编辑服务端配置文件 /etc/ssh/sshd_config&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="Mac" scheme="https://webw3c.github.io/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://webw3c.github.io/tags/Mac/"/>
    
    <category term="SSH" scheme="https://webw3c.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>超详细Hexo+Github Page搭建技术博客教程【持续更新】</title>
    <link href="https://webw3c.github.io/2018/12/20/hexo/"/>
    <id>https://webw3c.github.io/2018/12/20/hexo/</id>
    <published>2018-12-20T02:12:06.000Z</published>
    <updated>2020-09-25T10:29:01.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。</p><p>这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p><p>下面就开始吧~</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>准备 node 和 git 环境，<br>首先，安装 <a href="https://nodejs.org/en/">NodeJS</a>，因为 <a href="https://hexo.io/zh-cn/">Hexo</a> 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。<br>然后，安装 <a href="https://git-scm.com/">git</a>，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git</a> 教程。</p><p>两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。<br>在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz2nmvl6kej20g907dwet.jpg" alt="image"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href="https://hexo.io/zh-cn/">Hexo</a> 的详细文档。<br>在命令行输入执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line"><span class="built_in">cd</span> myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章Markdowm文件 </span></span><br><span class="line">└── themes  <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure><p>好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 回车就可以预览效果了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz2r6obbifj21bo0mfdjx.jpg" alt="image"></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。</p><h2 id="注册-Github"><a href="#注册-Github" class="headerlink" title="注册 Github"></a>注册 Github</h2><p>首先如果你还没有 Github 账号的先<a href="https://github.com/">注册</a>一个，具体过程如下</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz2ovhptzgj20n90rk12d.jpg" alt="image"></p><p>点击 Start project 或者下面的 new repository 创建一个新的仓库</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2p5l7j6cj20sk0h8wju.jpg" alt="image"></p><p>注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz2po2plspj20kr0hbtbb.jpg" alt="image"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World.</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz2q91ar2zj20s80e50va.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz2qami35uj20dt06a74t.jpg" alt="image"></p><p>这个时候打开 http://你的用户名.github.io 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 http://你的用户名.github.io 看到你自己的博客啦！ 比如我的就是 <a href="http://webw3c.github.io/">http://webw3c.github.io</a> 了。</p><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz2pwjzahzj20c0040mx4.jpg" alt="image"></p><h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p><p>打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz2rym90u1j20fr03jgm6.jpg" alt="image"></p><p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure><p>然后开始生成密钥 SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;上面的邮箱&#x27;</span></span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2s3i3zi0j20iz0anq7a.jpg" alt="image"></p><p>（此图引用自码云）</p><p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com </span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz2s6m2kjwj20fq01g3yg.jpg" alt="image"></p><p>到这还没完，还要登录 <a href="https://github.com/">Github</a> 上添加刚刚生成的SSH key，按以下步骤添加：</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz2s9u4bi4j205n0as0t0.jpg" alt="image"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2sc8liqmj20sb0c9jtg.jpg" alt="image"></p><h2 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h2><p>此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的<a href="https://hexo.io/zh-cn/docs/deployment">部署</a>教程。<br>先不着急，部署之前还需要修改配置和安装部署插件。<br>第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2srao2z2j20f104ewey.jpg" alt="image"></p><p>第二：要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： https://你的用户名.github.io 就会看到你的博客啦！！</p><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://hexo.io/zh-cn/">hexo</a> 官网。<br>新建文章，输入以下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;文章标题&#x27;</span></span><br></pre></td></tr></table></figure><p>执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。</p><p>在 Markdown 文章里面输入你的文章内容</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz5x2qhmzbj216e0c50us.jpg" alt="image"></p><p>再执行一下以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以看到你的文章在博客显示了，以下就是刚刚</p><p><img src="https://wx1.sinaimg.cn/large/889d1a94gy1fz5x6potcgj20vk0e10te.jpg" alt="image"></p><p>最后，只要部署到你的 Github 上就可以了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="静态图床"><a href="#静态图床" class="headerlink" title="静态图床"></a>静态图床</h2><p>文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是<a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules">测试域名</a>不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外<a href="https://sm.ms/">sm.ms</a>这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。</p><p>可以去chrome网上应用商店下载一个叫<a href="https://chrome.google.com/webstore/detail/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/pinjkilghdfhnkibhcangnpmcpdpmehk?hl=zh-CN">微博图床</a>的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz72py0lycj20nw0go40c.jpg" alt="image"></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>你可以到<a href="https://hexo.io/themes/">官网主题页</a>或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题<a href="http://theme-next.iissnan.com/getting-started.html">官网使用文档</a>说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。</p><h3 id="一、添加评论系统"><a href="#一、添加评论系统" class="headerlink" title="一、添加评论系统"></a>一、添加评论系统</h3><p><strong>* 注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置 *</strong></p><p>添加 <a href="https://valine.js.org/">valine</a> 评论系统，打开 /themes/next/_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz5yqhmvbqj20x009dq5c.jpg" alt="image"></p><p>然后到 leanCloud <a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a>或者<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a> 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz5ywov61yj20zj0ea777.jpg" alt="image"></p><h3 id="二、配置腾讯公益404页面"><a href="#二、配置腾讯公益404页面" class="headerlink" title="二、配置腾讯公益404页面"></a>二、配置腾讯公益404页面</h3><ol><li>在博客根目录 /source 文件夹下创建404.html（具体内容见下图及代码）；</li><li>在 html 上方加入上面3行代码；</li></ol><p>腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图</p><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz5zivfhysj210n0cpq5c.jpg" alt="image"></p><p>上图最前面的那几行也要加进去哦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: <span class="literal">false</span></span><br><span class="line">title: <span class="string">&quot;404&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这里放一下上面用到的几个js链接，来自腾讯公益404官方<a href="https://www.qq.com/404/">接入文档</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/plain&quot;</span> src=<span class="string">&quot;http://www.qq.com/404/search_children.js&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> homePageUrl=<span class="string">&quot;https://pojian.xyz&quot;</span> homePageName=<span class="string">&quot;回到我的博客主页&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://qzone.qq.com/gy/404/data.js&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://qzone.qq.com/gy/404/page.js&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你也可以直接复制我 Github 上的<a href="https://github.com/webw3c/webw3c.github.io/blob/master/404.html">404页面代码</a>，以下是我博客的预览效果。</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz5zpo960mj21hb0r5jxt.jpg" alt="image"></p><p>另外如果需要自定义个性化404页面的只要删除相应腾讯的JS，直接修改上面的 404.html 文件就可以了。</p><h3 id="三、添加字数统计和阅读时长"><a href="#三、添加字数统计和阅读时长" class="headerlink" title="三、添加字数统计和阅读时长"></a>三、添加字数统计和阅读时长</h3><p>首先安装一个插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>接着博客根目录下的配置文件里添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span></span><br><span class="line">  time: <span class="literal">true</span></span><br><span class="line">  total_symbols: <span class="literal">true</span></span><br><span class="line">  total_time: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后到 next 主题的配置文件下开启 symbols_count_time 字段</p><p><img src="https://ws4.sinaimg.cn/large/889d1a94gy1fz7fsfyw5hj20rx05gt97.jpg" alt="image"></p><p>重启一下 hexo 就可以看到效果啦</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz7fu1u1l8j20vq08p75j.jpg" alt="image"></p><h3 id="四、开启fancybox"><a href="#四、开启fancybox" class="headerlink" title="四、开启fancybox"></a>四、开启fancybox</h3><p>打开主题配置文件搜索 fancybox 设置为 true，另外，vendors 填上对应 CDN 地址即可开启</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7fy76s0uj20n50cimzp.jpg" alt="image"></p><h3 id="五、文章分享"><a href="#五、文章分享" class="headerlink" title="五、文章分享"></a>五、文章分享</h3><p>百度分享有个 https 的坑，按网上的方法把文件放到自己的服务器是我以前在其他的网站上测试过是能使用的，但在 hexo 中却报错了，具体不清楚是什么原因，感觉可能是 hexo 版本的问题，因为有的人可以，有的人报和我一样的错误，忘记截图了。因为这个功能也没有十分需要，就不继续爬了。换了 <a href="https://github.com/overtrue/share.js">share.js</a> 实现了同样的功能，具体可以看本文文末的效果。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>如果你感觉直接使用 github.io 的域名作为你的博客链接不够专业，不够程序员的话那么就购买一个域名解析绑定到你的博客，我也比较建议这样做。<br>我的是在阿里万网<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.17.365b4f157s4Od7">注册</a>的，注册流程比较常规这里就不多详述了，</p><p>注册登录控制台后找到你的域名，点右侧的解析按钮进去解析列表</p><p><img src="https://wx1.sinaimg.cn/large/889d1a94gy1fz68md161tj21hc0f3q6e.jpg" alt="image"><br><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fz68pz0zjuj21fw0dtwgt.jpg" alt="image"></p><p>点右边的“添加记录”添加两条 CNAME 类型的记录，如上图，后面的记录值就填写你们自己的 Github 地址哈</p><p>记录添加完后就要到 <a href="https://www.github.com/">Github</a> 设置绑定你购买的域名了，进入你的博客仓库点 Setting，然后拉到 GitHub Pages 那里填上你的申请购买的域名保存就可以了</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz68xr3w2fj20sf05xgmd.jpg" alt="image"><br><img src="https://ws4.sinaimg.cn/large/889d1a94gy1fz68zmvj8ij20l90i5gny.jpg" alt="image"></p><p>这里说下，当你点击保存的时候 Github Pages 会自动帮你生成一个 CNAME 的文件在根目录，里面的内容就是你绑定的域名地址</p><p><img src="https://wx1.sinaimg.cn/large/889d1a94gy1fz694nu6n0j20tp0a4abc.jpg" alt="image"></p><p>注意，如果是按上面的方法操作还会有一点小问题，就是当你执行 hexo d 部署你本地的文章到 Github 时，你本地的文件会全部覆盖掉你现有仓库上的所有内容，包括 Github Pages 帮你创建的那个 CNAME 文件，这样的话当你访问域名的时候又会访问不到了。所以呢，你需要自己手动在本地根目录 /source 目录下手动创建一个 CNAME 文件，内容就是你的域名地址，因为 source 目录下的文件部署的时候是不会被删除的，所以部署的时候也会一起被部署上去，最后还需要重新到你仓库 Setting，拉到 GitHub Pages 那里再一次绑定你的域名，这样以后就没问题了。</p><p>稍等一会就可以用你申请的域名就访问你的博客了！</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>接下来说下百度收录，据说 Github 屏蔽了百度的蜘蛛，也有的人说没，具体不是很清楚，Github 在2015的时候遭受了史上最大规模的DDoS攻击，有国外媒体指百度干的，具体不得而知啦，但感觉百度收录 Github 确认是比较难，时间也比较长，所以还是优化一下吧。</p><h3 id="一、代码同时部署到-coding"><a href="#一、代码同时部署到-coding" class="headerlink" title="一、代码同时部署到 coding"></a>一、代码同时部署到 coding</h3><p>那有什么方法呢？就是把博客站点同时托管在国内的 coding 平台上，这样收录就会容易很多，同时又不影响 Github 上的代码，<a href="https://coding.net/">coding</a> 是国内的一个提供代码托管服务的平台，跟 Github 差不多。使用方法也和 Github 差不多，下面我就具体说一下怎么把代码同时部署到 coding 和 Github 上面，让百度更容易收录。</p><p><a href="https://coding.net/register">注册</a>、<a href="https://coding.net/login">登录</a> coding 后创建一个新的仓库，注意点就是新建项目的时候命名规则和 Github 上的一样，就是 <strong>用户名.coding.me</strong> 可以看下图，还有记得别忘了添加 SSH key</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz78hhe593j20qw05dmxe.jpg" alt="image"></p><p>仓库建好后进入仓库，选左侧的 Page 服务，在设置中绑定新的域名，输入后点击绑定就可以了</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz78v08sssj21fn0ppgrv.jpg" alt="image"></p><p>接着到你的域名解析控制台修改添加两条 CNAME 记录指向你的 Page 地址，看下图，注意看记录值哦，换成你自己的。</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz78yh3racj21ay0czgnm.jpg" alt="image"></p><p>最后呢修改根目录下的 _config.yml 配置文件中的部署配置，把 coding 的 git 地址添加进去就行了</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz793dwgpfj20p005paak.jpg" alt="image"></p><p>最后执行部署命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>这时就可以在 coding 仓库中看到你提交部署的代码了，同时 你的用户名.coding.me 也可以访问你的博客站点了，这里 Github 和 coding 的代码是同时更新的，互不影响。而绑定的域名解析可能需要稍等一会才会生效。</p><h3 id="二、百度提交链接"><a href="#二、百度提交链接" class="headerlink" title="二、百度提交链接"></a>二、百度提交链接</h3><p>部署到 coding 后也不是百度就可以收录的，我们还需要继续优化。如果在百度搜索输入 site:你的域名 如果出现以下的效果证明就是网站还没被百度收录的，我们现在点下面的<a href="https://ziyuan.baidu.com/linksubmit/url">提交网址</a>，进入百度站长工具提交。</p><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz7a9r2nifj20w209x0ty.jpg" alt="image"></p><h3 id="三、百度站长平台添加网站管理"><a href="#三、百度站长平台添加网站管理" class="headerlink" title="三、百度站长平台添加网站管理"></a>三、百度站长平台添加网站管理</h3><p>注册<a href="https://ziyuan.baidu.com/site/">百度站长</a>工具，并添加网站</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7amrsnmoj20ym0aeabo.jpg" alt="image"></p><p>添加网站的过程有三步，主要操作集中在最后一步的网站验证方式里，我选择的是 HTML标签验证，按下面使用方法添加代码到你的网站即可</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz7atp67kej20s70l2tav.jpg" alt="image"></p><p>而使用 next 主题的同学可以直接在主题的配置文件下搜索 baidu_site_verification 后面填上第三步中 meta 标签中 content 的值就可以</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz7aydsnr6j20rz0asn02.jpg" alt="image"></p><p>最后点完成验证就可以通过了。</p><h3 id="四、添加sitemap站点地图"><a href="#四、添加sitemap站点地图" class="headerlink" title="四、添加sitemap站点地图"></a>四、添加sitemap站点地图</h3><p>站点地图包含了你网站上的站点链接，方便搜索引擎蜘蛛的抓取工作，搜索蜘蛛会通过网站地图中链接的深层次爬行，抓取新的内容。所以我们要生成 sitemap 文件助于网站优化，安装生成插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>接着在博客根目录下的配置文件里添加对应配置项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sitemap</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>注意缩进，要不会编译报错</p><p>还要修改一个根目录配置文件下的URL，url 一项的值改成你在百度站长平台里面添加的自己站点的地址，这样生成的 sitemap.xml 文件里的 url 才是你站点的地址，看下图</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7cay1xf9j20qc03wjrs.jpg" alt="image"></p><h3 id="五、添加蜘蛛协议robots-txt"><a href="#五、添加蜘蛛协议robots-txt" class="headerlink" title="五、添加蜘蛛协议robots.txt"></a>五、添加蜘蛛协议robots.txt</h3><p>增加 robots.txt 文件，就是蜘蛛协议，新建 robots.txt 文件添加以下内容，把 robots.txt 放在 /source 文件下，我们前面说过 /source 目录下的文件是会被打包上传的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo robots.txt</span></span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://pojian.xyz/sitemap.xml</span><br><span class="line">Sitemap: https://pojian.xyz/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow后面的就是你的menu，还有最下面的 Sitemap 地址请自行改成你们自己的地址</p><p>完成后，重启hexo，执行 hexo g -d 重新生成文件并提交后，在public目录下会生成对应的xml文件。可以通过 <a href="http://xxx.com/sitemap.xml">http://xxx.com/sitemap.xml</a> 和 <a href="http://xxx.com/baidusitemap.xml">http://xxx.com/baidusitemap.xml</a> 访问到 sitemap 文件，通过 <a href="http://xxx.com/robots.txt">http://xxx.com/robots.txt</a> 访问到 robots.txt 文件。</p><p>可以到百度站长检测一下 robots.txt 文件是否生效</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz7df4tdohj210m0pnag3.jpg" alt="image"></p><h3 id="六、自动推送"><a href="#六、自动推送" class="headerlink" title="六、自动推送"></a>六、自动推送</h3><p>百度有自动推送、主动推送、sitemap、手动提交几种方式。<br>自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。怎么安装呢？<br>如果你的是 next 主题，只要打开主题配置文件搜索找到 baidu_push 设置为 true 即可</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz7ee6cn1hj20s001hglo.jpg" alt="image"></p><p>如果你使用的不是 next 主题，也可以手动把以下代码粘贴到你的站点，一般放在 head 头部公共文件里面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var bp = document.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    var curProtocol = window.location.protocol.split(<span class="string">&#x27;:&#x27;</span>)[0];</span><br><span class="line">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span><br><span class="line">        bp.src = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        bp.src = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    var s = document.getElementsByTagName(<span class="string">&quot;script&quot;</span>)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="七、主动推送"><a href="#七、主动推送" class="headerlink" title="七、主动推送"></a>七、主动推送</h3><p>这里利用一个第三方插件 <a href="https://github.com/huiwang/hexo-baidu-url-submit">hexo-baidu-url-submit</a> 进行主动推送<br>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>添加想关配置到根目录下的配置文件里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度链接提交-主动推送配置</span></span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3 <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  host: pojian.xyz <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  token: 3GIEYsuq5ZTkvDBm <span class="comment">## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  path: baidu_urls.txt <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>添加新的部署配置，注意这里跟之前有点不一样，要在 type 前添加一个破折号 -</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - <span class="built_in">type</span>: git</span><br><span class="line">    repo:</span><br><span class="line">      github: https://github.com/webw3c/webw3c.github.io.git</span><br><span class="line">      coding: https://git.dev.tencent.com/yusting/yusting.coding.me.git</span><br><span class="line">  - <span class="built_in">type</span>: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>最后，执行 hexo deploy 的时候，新的连接就会被推送了。<br>** 实现原理 **<br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="八、手动推送"><a href="#八、手动推送" class="headerlink" title="八、手动推送"></a>八、手动推送</h3><p>就是直接直接把你需要提交的链接直接使用手动的方式填写提交就可以。</p><p>最后你可以看到是否已经被百度成功收录了</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7eumo8agj20ti0nkaez.jpg" alt="image"></p><p>如果抓取成功了就证明已经被收录了，好像一般不会这么快，我的等了两天左右才抓取得到。</p><h3 id="九、添加百度统计"><a href="#九、添加百度统计" class="headerlink" title="九、添加百度统计"></a>九、添加百度统计</h3><p>添加<a href="https://tongji.baidu.com/web/homepage/index">百度统计</a>就可以查看你网站相关的一些数据，便于你自己的站点</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz7f4xv3w1j21hc0cx79q.jpg" alt="image"></p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz7f64cwx8j21h00ec79e.jpg" alt="image"></p><h2 id="多端同步写作"><a href="#多端同步写作" class="headerlink" title="多端同步写作"></a>多端同步写作</h2><p>内容准备中…</p><h2 id="手机编写"><a href="#手机编写" class="headerlink" title="手机编写"></a>手机编写</h2><p>网上好像找不到什么资料，不过通过在手机端安装 SSH 客户端远程操作服务器端，安装配置 node / git / hexo 环境编写应该可以的，原理同多台电脑编写差不多，不过这样做不太省心，不折腾了哈。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章到这差不多啦！后续有些小点深入学习后还是会保持更新的，希望文章对曾经像我一样的小白有那么一点帮助，技术有限，难免有纰漏，欢迎指正批评和讨论，感谢阅读！:-)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金</summary>
      
    
    
    
    <category term="Hexo" scheme="https://webw3c.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://webw3c.github.io/tags/Hexo/"/>
    
    <category term="Github Page" scheme="https://webw3c.github.io/tags/Github-Page/"/>
    
    <category term="SEO" scheme="https://webw3c.github.io/tags/SEO/"/>
    
  </entry>
  
</feed>
